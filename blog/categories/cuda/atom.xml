<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CUDA | 零露漙兮]]></title>
  <link href="http://luoyulong.github.io/blog/categories/cuda/atom.xml" rel="self"/>
  <link href="http://luoyulong.github.io/"/>
  <updated>2014-07-03T10:53:46+08:00</updated>
  <id>http://luoyulong.github.io/</id>
  <author>
    <name><![CDATA[luoyulong]]></name>
    <email><![CDATA[luoyulong@ncic.ac.cn]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CUDA 计时的方法]]></title>
    <link href="http://luoyulong.github.io/blog/2014/07/02/cuda-timing/"/>
    <updated>2014-07-02T15:04:09+08:00</updated>
    <id>http://luoyulong.github.io/blog/2014/07/02/cuda-timing</id>
    <content type="html"><![CDATA[<h1>问题</h1>

<p>测试CUDA应用的时间</p>

<h1>解决方案</h1>

<p>引用自stackoverflow：</p>

<blockquote><p>You could do sth along the lines of :</p></blockquote>

<p>``` cuda</p>

<h1>include&lt;sys/time.h></h1>

<p>struct timeval t1, t2;</p>

<p>gettimeofday(&amp;t1, 0);</p>

<p>kernel_call&lt;&lt;&lt;dimGrid, dimBlock, 0>>>();</p>

<p>HANDLE_ERROR(cudaThreadSynchronize();)</p>

<p>gettimeofday(&amp;t2, 0);</p>

<p>double time = (1000000.0*(t2.tv_sec-t1.tv_sec) + t2.tv_usec-t1.tv_usec)/1000000.0;</p>

<p>printf(&ldquo;Time to generate:  %3.1f ms \n&rdquo;, time);
<code>
or:
</code>
float time;
cudaEvent_t start, stop;</p>

<p>HANDLE_ERROR( cudaEventCreate(&amp;start) );
HANDLE_ERROR( cudaEventCreate(&amp;stop) );
HANDLE_ERROR( cudaEventRecord(start, 0) );</p>

<p>kernel_call&lt;&lt;&lt;dimGrid, dimBlock, 0>>>();</p>

<p>HANDLE_ERROR( cudaEventRecord(stop, 0) );
HANDLE_ERROR( cudaEventSynchronize(stop) );
HANDLE_ERROR( cudaEventElapsedTime(&amp;time, start, stop) );</p>

<p>printf(&ldquo;Time to generate:  %3.1f ms \n&rdquo;, time);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ROSE 声明CUDA类型的变量]]></title>
    <link href="http://luoyulong.github.io/blog/2014/06/30/rose-cuda-varialbe/"/>
    <updated>2014-06-30T10:26:12+08:00</updated>
    <id>http://luoyulong.github.io/blog/2014/06/30/rose-cuda-varialbe</id>
    <content type="html"><![CDATA[<h1>问题</h1>

<p>需要声明CUDA类型的变量，如 constant,device,shared等等</p>

<h1>解决方案</h1>

<p>调用<code>get_declarationModifier().get_storageModifier().set</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[error: no instance of overloaded function "tex1Dfetch" matches the argument list argument types are: (texture<double, 1, cudaReadModeElementType>, int)  ]]></title>
    <link href="http://luoyulong.github.io/blog/2014/06/29/cudatexture/"/>
    <updated>2014-06-29T15:59:52+08:00</updated>
    <id>http://luoyulong.github.io/blog/2014/06/29/cudatexture</id>
    <content type="html"><![CDATA[<h1>问题</h1>

<p>在使用cuda的纹理存储器时，编译器报错
<code>bash
stencilexample.cu(147): error:
no instance of overloaded function "tex1Dfetch"
matches the argument list argument types are:
(texture&lt;double, 1, cudaReadModeElementType&gt;, int)
</code></p>

<h1>解决方法</h1>

<p>经过研究，发现原来cuda的纹理存储器不能直接支持double</p>

<blockquote><p>The type of a texel, which is restricted to the basic integer and single-precision floating-point types and any of the 1-, 2-, and 4-component vector types defined in char, short, int, long, longlong, float, double that are derived from the basic integer and single-precision floating-point types.
出处：<a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#texture-and-surface-memory" title="Title">cuda-c-programming-guide</a></p></blockquote>

<p>非要加速的话，可以使用一个int2类型的向量拼接成一个double
``` cuda
//declarate the texture using int2 type
texture &lt;int2,1,cudaReadModeElementType> Atex;</p>

<p>//used in global function(cuda kernel)
int2 A1=tex1Dfetch(Atex,(texoff+(ll+offset) <em>lda +ty+offset));
Bs[ty+offset][tx] &ndash;= __hiloint2double(A1.y,A1.x)</em>temp;</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>

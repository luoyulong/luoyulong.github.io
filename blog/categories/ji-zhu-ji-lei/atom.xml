<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 技术积累 | 零露漙兮]]></title>
  <link href="http://luoyulong.github.io/blog/categories/ji-zhu-ji-lei/atom.xml" rel="self"/>
  <link href="http://luoyulong.github.io/"/>
  <updated>2014-07-03T18:36:54+08:00</updated>
  <id>http://luoyulong.github.io/</id>
  <author>
    <name><![CDATA[luoyulong]]></name>
    <email><![CDATA[luoyulong@ncic.ac.cn]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CUDA 优化经验]]></title>
    <link href="http://luoyulong.github.io/blog/2014/07/03/gpuexperiences/"/>
    <updated>2014-07-03T17:45:10+08:00</updated>
    <id>http://luoyulong.github.io/blog/2014/07/03/gpuexperiences</id>
    <content type="html"><![CDATA[<h1>硬件模型</h1>

<ol>
<li><p>shared-memoy在硬件层是以SM为单位，在逻辑层是以block为单位</p></li>
<li><p>warp是GPU在硬件层的并行单位。一般来说，warp等于32. SM在处理一个block kernel时，会经可能多的发射warp，每个warp内线程的大小为32.</p></li>
<li><p><span id="anchor1"></span>每个SM可以同时驻留多个 block执行（active block），这主要取决于当前SM是否拥有足够的硬件资源，如Register，shared-memory等等.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p></li>
<li><p>在200机器上的GPU，每个SM拥有256*256个32位的寄存器（即平均每个线程有256个32-bite的寄存器），49152byte的shared memory,65536byte的constant memory。</p></li>
</ol>


<h1>优化原则</h1>

<ol>
<li><p>把部分无共享的shared-memory变为global memory， 并没有增加速度，推测是因为对shared-memory减少的还不够 不足以使得同时在SM运行的block增加。（已经验证）</p></li>
<li><p>有些常量经常被用到，且占用的空间很小。之前使用常量存储器，现改用参数传递，放入寄存器进行加速。</p></li>
<li><p>把与threadIdx无关的公共计算提到host端计算，再把结果使用参数传递给kernel函数</p></li>
<li><p>写回的变量不使用shared-memory</p></li>
<li><p>shared-memory和分块大小之间有一个<a href="#anchor1">tradeoff</a>，即越多的shared-memory会导致在同一SM上驻留的block减少，但同时其访存的性能会上升</p></li>
</ol>


<h1>CUDA手册:性能优化</h1>

<p>Performance optimization revolves around three basic strategies:<em> Maximize parallel execution to achieve maximum utilization;</em> Optimize memory usage to achieve maximum memory throughput;* Optimize instruction usage to achieve maximum instruction throughput</p>

<h2>Maximize Utilization</h2>

<h3>Application Level</h3>

<h3>Device Level</h3>

<ol>
<li>For devices of compute capability 1.x, only one kernel can execute on a device at one time, so the kernel should be launched with at least <strong>as many thread blocks as</strong> there are multiprocessors in the device.2. For devices of compute capability 2.x and higher, multiple kernels can <strong>execute concurrently</strong> on a device, so maximum utilization can also be achieved by using streams to enable enough kernels to execute concurrently as described in Asynchronous Concurrent Execution.</li>
</ol>


<h3>Multiprocessor Level</h3>

<h2>Maximize Memory Throughput</h2>

<h3>Device Memory Accesses</h3>

<h4>Shared MemoryBecause it is on-chip, shared memory has much higher bandwidth and much lower latency than local or global memory.To achieve high bandwidth, shared memory is divided into equally-sized memory modules, called banks, which can be accessed simultaneously. Any memory read or write request made of n addresses that fall in n distinct memory banks can therefore be serviced simultaneously, yielding an overall bandwidth that is n times as high as the bandwidth of a single module.However, if two addresses of a memory request fall in the same memory bank, there is a <strong>bank conflict</strong> and the access has to be serialized. The hardware splits a memory request with bank conflicts into as many separate conflict-free requests as necessary, decreasing throughput by a factor equal to the number of separate memory requests. If the number of separate memory requests is n, the initial memory request is said to cause n-way bank conflicts.To get maximum performance, it is therefore important to understand how memory addresses map to memory banks in order to schedule the memory requests so asto minimize bank conflicts. This is described in Compute Capability 1.x,Compute Capability 2.x, Compute Capability 3.x, and Compute Capability 5.0 for devices of compute capability 1.x, 2.x, 3.x, and 5.0, respectively.</h4>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>详见http://stackoverflow.com/questions/12212003/how-concurrent-blocks-can-run-a-single-gpu-streaming-multiprocessor/12213137#12213137<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CUDA 计时的方法]]></title>
    <link href="http://luoyulong.github.io/blog/2014/07/02/cuda-timing/"/>
    <updated>2014-07-02T15:04:09+08:00</updated>
    <id>http://luoyulong.github.io/blog/2014/07/02/cuda-timing</id>
    <content type="html"><![CDATA[<h1>问题</h1>

<p>测试CUDA应用的时间</p>

<h1>解决方案</h1>

<p>引用自stackoverflow：</p>

<blockquote><p>You could do sth along the lines of :</p></blockquote>

<p>``` cuda</p>

<h1>include&lt;sys/time.h></h1>

<p>struct timeval t1, t2;</p>

<p>gettimeofday(&amp;t1, 0);</p>

<p>kernel_call&lt;&lt;&lt;dimGrid, dimBlock, 0>>>();</p>

<p>HANDLE_ERROR(cudaThreadSynchronize());</p>

<p>gettimeofday(&amp;t2, 0);</p>

<p>double time = (1000000.0*(t2.tv_sec-t1.tv_sec) + t2.tv_usec-t1.tv_usec)/1000000.0;</p>

<p>printf(&ldquo;Time to generate:  %3.1f ms \n&rdquo;, time);
<code>
or:
</code>
float time;
cudaEvent_t start, stop;</p>

<p>HANDLE_ERROR( cudaEventCreate(&amp;start) );
HANDLE_ERROR( cudaEventCreate(&amp;stop) );
HANDLE_ERROR( cudaEventRecord(start, 0) );</p>

<p>kernel_call&lt;&lt;&lt;dimGrid, dimBlock, 0>>>();</p>

<p>HANDLE_ERROR( cudaEventRecord(stop, 0) );
HANDLE_ERROR( cudaEventSynchronize(stop) );
HANDLE_ERROR( cudaEventElapsedTime(&amp;time, start, stop) );</p>

<p>printf(&ldquo;Time to generate:  %3.1f ms \n&rdquo;, time);
```</p>

<p>其中，在cpu端计时，由于GPU的kenernl与cpu是异步执行，所以在获得整个cuda应用的结束时间前，必须要调用cudaThreadSynchronize（现替换成cudaDeviceSynchronize），否则测的时间是最后一个kernel 启动的时间。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ROSE 在源文件的include语句之前插入语句]]></title>
    <link href="http://luoyulong.github.io/blog/2014/07/01/rose-insertstatementbeforeheader/"/>
    <updated>2014-07-01T11:50:40+08:00</updated>
    <id>http://luoyulong.github.io/blog/2014/07/01/rose-insertstatementbeforeheader</id>
    <content type="html"><![CDATA[<h1>问题</h1>

<p>今天，在使用ROSE自动生成CUDA代码时，遇到一个问题：程序中需要使用纹理存储器对GPU访存进行加速，相应地要生成texture变量声明的代码。由于texture初始化时使用到一个宏，该宏定义在文件头部，这就使得texture的初始化必须在宏定义之后。翻遍了手册，找不到把语句插入preprocessinfo 结点（include，#define ）之后的方法，于是退一步打算找到当前scope中第一个语句，然后插到该语句之后。本打算调用firststatement的方法，报错，并且scope中的statement并不全是源码中的语句，会包含一些头文件中的结点。</p>

<h1>解决方法</h1>

<p>通过比较scope和scope中语句的名字，找到当前源文件中第一个SgStatement
``` c++
 //find the first statement of current source file
  SgStatement<em> firststatement=NULL;
  SgStatementPtrList statelist=currentscope->generateStatementList();
  for(int i=0;i&lt;statelist.size();i++)
  {
  SgStatement</em> tmp=statelist[i];
  if(tmp->get_file_info()&ndash;>get_filenameString()==currentscope->get_file_info()&ndash;>get_filenameString())</p>

<pre><code>{
firststatement=tmp;
break;
}
</code></pre>

<p>   }</p>

<pre><code>                                                                 }
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[检测Linux下 ODBC是否配置成功]]></title>
    <link href="http://luoyulong.github.io/blog/2014/06/30/linuxodbc/"/>
    <updated>2014-06-30T21:48:21+08:00</updated>
    <id>http://luoyulong.github.io/blog/2014/06/30/linuxodbc</id>
    <content type="html"><![CDATA[<h1>问题</h1>

<p>测试ODBC安装是否成功</p>

<h1>解决方案</h1>

<p>使用isql测试数据源是否配置正确
``` bash</p>

<h1>dbname:the username of target database</h1>

<h1>dbpsw: the password of target database</h1>

<p>imysql -v datasourcename dbname dbpsw
```
如果数据源配置正确，会出现进入数据库</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ROSE 创建模板类变量的一个取巧办法]]></title>
    <link href="http://luoyulong.github.io/blog/2014/06/30/rose-create-template-variable/"/>
    <updated>2014-06-30T09:42:36+08:00</updated>
    <id>http://luoyulong.github.io/blog/2014/06/30/rose-create-template-variable</id>
    <content type="html"><![CDATA[<h1>问题</h1>

<p>用ROSE产生cuda代码时，为了性能需要，使用到了纹理存储器。但在纹理存储器变量声明的时候，遇到了点问题：纹理寄存器变量的类型是模板类实例，e.g,<code>texture&lt;DATATYPE,1,cudaReadModeElementType&gt; t_a</code>,但是rose中模板类变量貌似不怎么好声明，尝试了半天都没有成功。</p>

<h1>解决方案</h1>

<p>使用万金油式的buildOpaqueType直接创建模板类型,然后使用该类型创建纹理存储器变量</p>

<p>``` c++</p>

<p>//create a template instance type directly: texture&lt;DATATYPE,1,cudaReadModelElementType>
SgType* textureType=buildOpaqueType(&ldquo;texture&lt;DATATYPE,1,cudaReadModelElementType>&rdquo;,node->get_scope());</p>

<p>//create the texture type variable &ldquo;texture_a&rdquo;
SgVariableDeclaration* vdecl=buildVariableDeclaration(&ldquo;texture_a&rdquo;,textureType,node->get_scope());</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
